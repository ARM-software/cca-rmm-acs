# Arm RMM ACS GIC Testcase checklist
-----------------------------------------------------

This document presents the mapping of the rules in the RMM specification to the
test cases and the steps followed in the tests. This also provides the information
about the test coverage scenarios that are implemented in the current release of
ACS and the scenarios that are planned for the future releases.


| Test Number | Test Name             | Test Assertion                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Test Steps                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Validated by ACS |
| ----------- | --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| 1           | gic_ctrl_list_invalid | The value of entry.gicv3_lrs[n] is valid if all of the following are true:<br>• The value is an architecturally valid encoding of ICH_LR_EL2 according to Arm Generic Interrupt Controller (GIC) Architecture Specification version 3 and version 4 [6].HW == '0'.<br>The GICv3 architecture states that, if HW == '1' then the virtual interrupt must be linked to a physical interrupt whose state is Active, otherwise behavior is undefined. The RMM is unable to validate that invariant, so it imposes the constraint that HW == '0'.    | 1\. Create the realm<br>2\. Set rec entry gicv3_lrs[0] state[63:62]=0x1(pending) and HW[61]=0x1<br>3\. Rec enter to realm and check for error status code.<br>4\. Repeat step 2 and 3 by setting state[63:62]=0x2(active) and HW[61]=0x1<br>5\. Repeat step 2 and 3 by setting state[63:62]=0x3(pending and active) and HW[61]=0x1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Yes              |
| 2           | gic_ctrl_hcr_invalid | The value of entry.gicv3_hcr is valid if the value is an architecturally valid encoding of ICH_HCR_EL2 according to Arm Generic Interrupt Controller (GIC) Architecture Specification version 3 and version 4.<br><br>On REC entry, fields in entry.gicv3_hcr must be set to 0 except for the following.<br>                                                                                                                                                                                                                                             | 1\. Create the realm<br>2\. Set rec entry gicv3_hcr[31:8] RES0 fields.<br>3\. Rec enter to realm and check for error status code.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Yes              |
| 3           | gic_ctrl_list         | On REC entry, ICH_LR_EL2 is set to entry.gicv3_lrs[n], for all values of n supported by the PE<br><br>On REC exit, exit.gicv3_lrs[n] contains the value of ICH_LR<n>_EL2 at the time of the Realm exit, for all values of n supported by the PE                                                                                                                                                                                                                                                                                                | 1\. Create the realm<br>2\. Program a Pending interrupt gicv3_lrs[0] state[63:62]=0x1(pending) into a List Register<br>3\. Enter Realm<br>4\. Read IAR<br>5\. Exit Realm without writing EOIR<br>6\. check Interrupt status @vINTID should be Active<br>7\. Enter Realm and write to EOIR<br>8\. Exit Realm<br>9\. check Interrupt @vINTID should now be Inactive.<br><br>11\. Repeat step 1 to step 9 for Gropu 1 interrupts for SPI, PPI and SGI<br>12\. Program an Inactive interrupt  gicv3_lrs[0] state[63:62]=0x0(inactive) into a List Register<br>13\. Enter Realm and read IAR<br>14\. Exit Realm without writing EOIR and check for Interrupt @vINTID should be Inactive<br><br>16\. Repeat step 12 to step 14 for Gropu 1 interrupts for SPI, PPI and SGI                                                                   | Yes               |
| 4           | gic_ctrl_list          | On REC entry, the following fields in ICH_HCR_EL2 are set to the corresponding values in entry.gicv3_hcr:<br>• UIE<br>• LRENPIE<br>• NPIE<br>• VGrp0EIE<br>• VGrp0DIE<br>• VGrp1EIE<br>• VGrp1DIE<br>• TDIR<br>On REC exit, ICH_HCR_EL2.En == '0'.                                                                                                                                                                                                                                                                                             | UIE:<br>Set ICH_HCR_EL2.UIE<br>Program two List Registers with valid interrupts<br>Enter Realm<br>Handle one interrupt (IAR read + EOIR write)<br>Read exit.gicv3_misr.U<br>An "Underflow" maintenance interrupt should be triggered<br>LRENPIE:<br>Set ICH_HCR_EL2.LRENPIE<br>Enter Realm<br>Write to EOIR with an INTID not present in any List Register<br>Read exit.gicv3_misr.LRENP<br>A "Not Present" maintenance interrupt should be triggered<br>NPIE:<br>Set ICH_HCR_EL2.NPIE<br>Program List Register with a valid pending interrupt<br>Enter Realm<br>Read IAR<br>Read exit.gicv3_misr.NP<br>A "No Pending" maintenance interrupt should be triggered<br>TDIR:<br>Set ICH_HCR_EL2.TDIR<br>Enter Realm<br>Write to ICV_DIR_EL1<br>The write should be trapped at R-EL2 and control goes back to NS-EL2<br>EOIcount:<br>check exit.gicv3_hcr.EOIcount at the end of all scenarios described above<br>En:<br>check exit.gicv3_hcr.En at the end of all scenarios described above | Yes               |
| 5           | gic_ctrl_vmcr         | On REC exit, exit.gicv3_vmcr contains the value of ICH_VMCR_EL2 at the time of the Realm exit.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                             | VPMR:<br>Read alias ICV_PMR_EL1.Priority from within Realm<br>Compare with exit.gicv3_vmcr.VPMR<br>VBPR0/1:<br>Read alias ICV_BPR0/1_EL1.BinaryPoint from within Realm<br>Compare with exit.gicv3_vmcr.VBPR0/1<br>VEOIM :<br>Read alias ICV_CTLR_EL1.EOImode from within Realm<br>Compare with exit.gicv3_vmcr.VEOIM<br>VENG0/1:<br>Read alias ICV_IGRPEN0/1_EL1.Enable from within Realm<br>Compare with exit.gicv3_vmcr.VENG0/1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Yes               |
| 6           | gic_timer_rel1_trig      | On REC exit, Realm EL1 timer state is exposed via the RecExit object:<br>• exit.cntv_ctl contains the value of CNTV_CTL_EL0 at the time of the Realm exit.<br>• exit.cntv_cval contains the value of CNTV_CVAL_EL0 at the time of the Realm exit, expressed as if the<br>virtual counter offset was zero.<br>• exit.cntp_ctl contains the value of CNTP_CTL_EL0 at the time of the Realm exit.<br>• exit.cntp_cval contains the value of CNTP_CVAL_EL0 at the time of the Realm exit, expressed as if the<br>physical counter offset was zero. | Execute for: X = {P, V}<br><br>Where:<br>P = Physical Timer<br>V = Virtual Timer<br><br>Program the EL1 timer to fire at t = t0 from within the Realm<br>CNTX_CTL_EL0.ENABLE = interrupt_enabled<br>CNTX_CTL_EL0.IMASK = not_masked<br>CNTX_CVAL_EL0 = t0 + CNTXCT_EL0<br>On Host side, verify that:<br>a REC Exit due to IRQ occurred<br>exit.cntXctl.ISTATUS = interrupt fired<br>exit.cntX_ctl.IMASK = not_masked<br>exit.cntX_ctl.ENABLE = interrupt_enabled<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Yes               |
| 7           | gic_timer_nsel2_trig       | If the Host has programmed an EL2 timer to assert its output during Realm execution, that timer output is guaranteed to assert.                                                                                                                                                                                                                                                                                                                                                                                                             | Program the EL2 timer to fire from the Host side<br>Enter the Realm and wait until the timer fires<br>On Host side, verify that a REC Exit due to IRQ occurred                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Yes               |
| 8           | gic_timer_val_read        | Both the virtual and physical counter values are guaranteed to be monotonically increasing when read by a Realm, in accordance with the architectural counter behavior<br>When read by a Realm, either the virtual or physical counter returns the same value at a given point in time on a given PE                                                                                                                                                                                                                                           | Read CNTPCT_EL0 and CNTVCT_EL0 at t = t0<br>Read CNTPCT_EL0 and CNTVCT_EL0 again at t = t1<br>Verify that phys_count.t1 > phys_count.t0 && virt_count.t1 > virt_count.t0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Yes               |
